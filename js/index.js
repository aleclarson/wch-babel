// Generated by CoffeeScript 2.3.0
var fs, path, resolvePath, wch;

({resolvePath} = require('resolve'));

path = require('path');

wch = require('wch');

fs = require('fsx');

// TODO: Unload babel modules when this plugin is stopped.
module.exports = function(log) {
  var babelCache, build, clear, compile, debug, loadBabel, shortPath, watchOptions;
  debug = log.debug('wch-babel');
  babelCache = {};
  loadBabel = function(pack) {
    var babel, babelPath;
    if (!(babelPath = resolvePath('babel-core', {
      parent: pack.path
    }))) {
      log.warn(`Cannot resolve 'babel-core' from '${pack.path}'`);
      return null;
    }
    if (!(babel = babelCache[babelPath])) {
      log(log.lyellow('Loading:'), shortPath(babelPath));
      babel = require(babelPath).transformFileSync;
      babelCache[babelPath] = babel;
    }
    return babel;
  };
  shortPath = function(path) {
    return path.replace(process.env.HOME, '~');
  };
  compile = function(file) {
    var code, err, loc, mtime;
    try {
      mtime = fs.stat(file.dest).mtime.getTime();
    } catch (error) {}
    if (mtime && mtime > file.mtime_ms) {
      return;
    }
    debug('Transpiling:', shortPath(file.path)); // TODO: source maps
    try {
      ({code} = this.compile(file.path, {
        highlightCode: false
      }));
      return [code, file];
    } catch (error) {
      err = error;
      loc = [err.loc.line - 1, err.loc.column];
      wch.emit('file:error', {
        file: file.path,
        message: err.message.slice(file.path.length + 2),
        location: [loc, loc]
      });
      debug(log.red('Failed to compile:'), shortPath(file.path));
    }
  };
  build = wch.pipeline().map(compile).save(function(file) {
    return file.dest;
  }).each(function(dest, file) {
    return wch.emit('file:build', {
      file: file.path,
      dest
    });
  });
  clear = wch.pipeline().delete(function(file) {
    return file.dest;
  }).each(function(dest, file) {
    return wch.emit('file:delete', {
      file: file.path,
      dest
    });
  });
  watchOptions = {
    only: ['*.js'],
    skip: ['**/__*__/**'],
    fields: ['name', 'exists', 'new', 'mtime_ms'],
    crawl: true
  };
  return {
    attach: function(pack) {
      var changes, dest;
      pack.compile = loadBabel(pack);
      // TODO: Emit a warning via `wch.emit`
      if (!pack.compile) {
        return;
      }
      dest = path.dirname(path.resolve(pack.path, pack.main || 'js/index'));
      changes = pack.stream('src', watchOptions);
      return changes.on('data', function(file) {
        var action;
        file.dest = path.join(dest, file.name);
        action = file.exists ? build : clear;
        return action.call(pack, file).catch(function(err) {
          log(log.red('Error while processing:'), file.path);
          return console.error(err.stack);
        });
      });
    }
  };
};
